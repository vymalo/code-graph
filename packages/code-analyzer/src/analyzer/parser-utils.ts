import * as path from 'path';
import * as crypto from 'crypto';
import fsPromises from 'fs/promises';
import * as fsSync from 'fs'; // Keep sync version for path resolution checks
import {FileSystemError} from '../utils/errors.js';
import {InstanceCounter} from './types.js';
import config from '../config/index.js';

const TEMP_DIR = config.tempDir; // Use tempDir from config

/**
 * Ensures the temporary directory for intermediate results exists.
 */
export async function ensureTempDir(): Promise<void> {
    try {
        await fsPromises.mkdir(TEMP_DIR, {recursive: true});
    } catch (error: any) {
        throw new FileSystemError(`Failed to create temporary directory: ${TEMP_DIR}`, {originalError: error});
    }
}

/**
 * Generates a unique temporary file path based on the source file path hash.
 * @param sourceFilePath - The absolute path of the source file.
 * @returns The absolute path for the temporary JSON file.
 */
export function getTempFilePath(sourceFilePath: string): string {
    // Normalize path before hashing for consistency
    const normalizedPath = sourceFilePath.replace(/\\/g, '/');
    const hash = crypto.createHash('sha256').update(normalizedPath).digest('hex');
    return path.join(TEMP_DIR, `${hash}.json`);
}

/**
 * Resolves a relative import path to an absolute path, attempting to find the correct file extension.
 * @param sourcePath - The absolute path of the file containing the import.
 * @param importPath - The relative or module path string from the import statement.
 * @returns The resolved absolute path or the original importPath if it's likely a node module or alias.
 */
export function resolveImportPath(sourcePath: string, importPath: string): string {
    // If it's not a relative path, assume it's a node module or alias (handled later by resolver)
    if (!importPath.startsWith('.')) {
        return importPath;
    }

    const sourceDir = path.dirname(sourcePath);
    // Remove .js/.jsx extension if present, as we want to find the .ts/.tsx source
    const importPathWithoutJsExt = importPath.replace(/\.jsx?$/i, '');
    let resolvedPath = path.resolve(sourceDir, importPathWithoutJsExt);

    // Attempt to resolve extension if missing
    if (!path.extname(resolvedPath)) {
        const extensions = config.supportedExtensions; // Use extensions from config
        let found = false;
        // Check for file with extension
        for (const ext of extensions) {
            try {
                if (fsSync.statSync(resolvedPath + ext).isFile()) {
                    resolvedPath += ext;
                    found = true;
                    break;
                }
            } catch { /* Ignore */
            }
        }
        // Check for index file in directory if file wasn't found directly
        if (!found) {
            for (const ext of extensions) {
                const indexPath = path.join(resolvedPath, `index${ext}`);
                try {
                    if (fsSync.statSync(indexPath).isFile()) {
                        resolvedPath = indexPath;
                        found = true;
                        break;
                    }
                } catch { /* Ignore */
                }
            }
        }
        // If still not found, return the original resolved path without extension.
        // The relationship resolver might handle this later based on available nodes.
    }
    // Normalize path separators for consistency
    return resolvedPath.replace(/\\/g, '/');
}

/**
 * Generates a stable, unique identifier for a code entity based on its type and qualified name.
 * Ensures consistency across analysis runs. Normalizes path separators and converts to lowercase.
 * @param prefix - The type of the entity (e.g., 'class', 'function', 'file', 'directory'). Lowercase.
 * @param qualifiedName - A unique name within the project context (e.g., 'path/to/file:ClassName').
 *                        Should be consistently generated by the parsers.
 * @returns The generated entity ID string.
 */
export function generateEntityId(prefix: string, qualifiedName: string): string {
    if (!prefix || !qualifiedName) {
        console.warn(`generateEntityId called with empty prefix or qualifiedName. Prefix: ${prefix}, QN: ${qualifiedName}`);
        // Potentially throw an error or return a placeholder
        return `${prefix || 'unknown'}:${qualifiedName || 'unknown'}:${Date.now()}`; // Add timestamp for some uniqueness
    }
    // Normalize path separators, convert to lowercase, and sanitize characters
    const safeIdentifier = qualifiedName
        .replace(/\\/g, '/') // Normalize slashes FIRST
        .toLowerCase()       // Convert to lowercase for case-insensitivity
        .replace(/[^a-z0-9_.:/-]/g, '_'); // Allow specific chars (adjusted for lowercase), replace others
    return `${prefix.toLowerCase()}:${safeIdentifier}`; // Ensure prefix is lowercase too
}

/**
 * Generates a unique instance ID for a node or relationship within the context of a single file parse.
 * Primarily used for temporary identification during parsing.
 * @param instanceCounter - The counter object for the current file parse.
 * @param prefix - The type of the element (e.g., 'class', 'function', 'calls'). Lowercase.
 * @param identifier - A descriptive identifier (e.g., qualified name, source:target).
 * @param options - Optional line and column numbers for added uniqueness context.
 * @returns The generated instance ID string.
 */
export function generateInstanceId(
    instanceCounter: InstanceCounter,
    prefix: string,
    identifier: string,
    options: { line?: number; column?: number } = {}
): string {
    if (!prefix || !identifier) {
        console.warn(`generateInstanceId called with empty prefix or identifier. Prefix: ${prefix}, ID: ${identifier}`);
    }
    const safeIdentifier = identifier
        .replace(/\\/g, '/')
        .replace(/[^a-zA-Z0-9_.:/-]/g, '_');

    let contextSuffix = '';
    // Include line/column if available for better debugging/uniqueness
    if (options.line !== undefined) contextSuffix += `:L${options.line}`;
    if (options.column !== undefined) contextSuffix += `:C${options.column}`;

    const counter = ++instanceCounter.count; // Increment counter for uniqueness within the file
    // Format: type:identifier:Lline:Ccol:counter
    const id = `${prefix}:${safeIdentifier}${contextSuffix}:${counter}`;
    return id;
}